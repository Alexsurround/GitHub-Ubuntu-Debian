# Синхронизация локального репозитория с GitHub

## Содержание
- [Введение](#введение)
- [Диагностика расхождений](#диагностика-расхождений)
- [Сценарий 1: Локальные изменения не закоммичены](#сценарий-1-локальные-изменения-не-закоммичены)
- [Сценарий 2: Локальные коммиты не отправлены](#сценарий-2-локальные-коммиты-не-отправлены)
- [Сценарий 3: Удалённый репозиторий впереди](#сценарий-3-удалённый-репозиторий-впереди)
- [Сценарий 4: Конфликт истории (diverged)](#сценарий-4-конфликт-истории-diverged)
- [Сценарий 5: Решение конфликтов при слиянии](#сценарий-5-решение-конфликтов-при-слиянии)
- [Сценарий 6: Отмена изменений](#сценарий-6-отмена-изменений)
- [Сценарий 7: Принудительная перезапись](#сценарий-7-принудительная-перезапись)
- [Полезные команды](#полезные-команды)
- [Рекомендации и best practices](#рекомендации-и-best-practices)

---

## Введение

Когда локальный репозиторий отличается от удалённого на GitHub, это нормальная ситуация в процессе разработки. Главное — правильно определить тип расхождения и выбрать подходящую стратегию синхронизации.

**Основные причины расхождений:**
- Вы внесли изменения локально, но не отправили их на GitHub
- Кто-то другой отправил изменения на GitHub
- Вы работаете в разных ветках
- Произошёл конфликт при одновременной работе

---

## Диагностика расхождений

### Проверка статуса репозитория

```bash
# Показать текущее состояние файлов
git status

# Показать разницу с удалённым репозиторием
git fetch origin
git status

# Посмотреть историю коммитов
git log --oneline --graph --all --decorate

# Сравнить локальную и удалённую ветки
git log HEAD..origin/main --oneline
git log origin/main..HEAD --oneline
```

### Обновление информации о удалённом репозитории

```bash
# Получить информацию об изменениях (без слияния)
git fetch origin

# Посмотреть все удалённые ветки
git branch -r

# Посмотреть все ветки (локальные и удалённые)
git branch -a
```

---

## Сценарий 1: Локальные изменения не закоммичены

**Ситуация:** Вы изменили файлы, но ещё не сделали `git commit`.

### Проверка
```bash
git status
```

Вывод покажет:
```
Changes not staged for commit:
  modified:   file1.txt
  modified:   file2.txt
```

### Решение A: Сохранить изменения и отправить на GitHub

```bash
# 1. Добавить изменённые файлы в staging
git add file1.txt file2.txt
# или добавить все изменения
git add .

# 2. Создать коммит
git commit -m "Описание внесённых изменений"

# 3. Отправить на GitHub
git push origin main
```

### Решение B: Временно отложить изменения (stash)

```bash
# Сохранить изменения во временное хранилище
git stash save "Описание изменений"

# Посмотреть список отложенных изменений
git stash list

# Продолжить работу, синхронизироваться с GitHub
git pull origin main

# Вернуть отложенные изменения
git stash pop

# Если возникли конфликты, решите их и продолжите
```

### Решение C: Отменить изменения

```bash
# ОСТОРОЖНО: Это удалит все незакоммиченные изменения!

# Отменить изменения в конкретном файле
git checkout -- file1.txt

# Отменить все изменения
git checkout -- .

# Альтернатива (современный синтаксис)
git restore file1.txt
git restore .
```

---

## Сценарий 2: Локальные коммиты не отправлены

**Ситуация:** Вы сделали коммиты локально, но не выполнили `git push`.

### Проверка
```bash
git status
```

Вывод покажет:
```
Your branch is ahead of 'origin/main' by 2 commits.
  (use "git push" to publish your local commits)
```

### Решение: Отправить коммиты на GitHub

```bash
# Простая отправка
git push origin main

# Если ветка называется иначе (например, master)
git push origin master

# Установить ветку по умолчанию для push
git push -u origin main
```

---

## Сценарий 3: Удалённый репозиторий впереди

**Ситуация:** На GitHub появились новые коммиты, которых нет у вас локально.

### Проверка
```bash
git fetch origin
git status
```

Вывод покажет:
```
Your branch is behind 'origin/main' by 3 commits.
  (use "git pull" to update your local branch)
```

### Решение A: Обновить локальный репозиторий (рекомендуется)

```bash
# Получить и слить изменения
git pull origin main

# Это эквивалентно:
git fetch origin
git merge origin/main
```

### Решение B: Обновить с rebase

```bash
# Применить локальные коммиты поверх удалённых
git pull --rebase origin main

# Это создаст более чистую историю коммитов
```

**Разница между merge и rebase:**
- **merge**: Создаёт новый коммит слияния, сохраняет всю историю
- **rebase**: Перемещает ваши коммиты на вершину, создаёт линейную историю

---

## Сценарий 4: Конфликт истории (diverged)

**Ситуация:** И локальный, и удалённый репозитории имеют уникальные коммиты.

### Проверка
```bash
git fetch origin
git status
```

Вывод покажет:
```
Your branch and 'origin/main' have diverged,
and have 2 and 3 different commits each, respectively.
```

### Решение A: Слияние изменений (merge)

```bash
# 1. Получить изменения с GitHub
git fetch origin

# 2. Слить изменения
git merge origin/main

# 3. Если конфликтов нет, отправить результат
git push origin main

# 4. Если есть конфликты, см. Сценарий 5
```

### Решение B: Rebase (для более чистой истории)

```bash
# 1. Получить изменения
git fetch origin

# 2. Применить ваши коммиты поверх удалённых
git rebase origin/main

# 3. Если конфликты, решите их:
# - Отредактируйте конфликтующие файлы
# - git add <файл>
# - git rebase --continue

# 4. Отправить изменения
git push origin main
```

**ВАЖНО:** Не используйте rebase для веток, которые уже опубликованы и используются другими разработчиками!

### Решение C: Создать ветку для слияния

```bash
# 1. Создать новую ветку для безопасного слияния
git checkout -b merge-branch

# 2. Слить изменения из main
git merge origin/main

# 3. Решить конфликты
# 4. Отправить ветку на GitHub
git push origin merge-branch

# 5. Создать Pull Request на GitHub для code review
```

---

## Сценарий 5: Решение конфликтов при слиянии

**Ситуация:** Git не может автоматически слить изменения из-за конфликтов.

### Признаки конфликта

```bash
git merge origin/main
# или
git pull origin main
```

Вывод:
```
Auto-merging file.txt
CONFLICT (content): Merge conflict in file.txt
Automatic merge failed; fix conflicts and then commit the result.
```

### Пошаговое решение конфликта

#### Шаг 1: Определить конфликтующие файлы
```bash
git status
```

Вывод покажет:
```
Unmerged paths:
  both modified:   file.txt
```

#### Шаг 2: Открыть конфликтующий файл

Конфликты обозначены маркерами:
```
<<<<<<< HEAD
Ваша локальная версия кода
=======
Версия кода из GitHub
>>>>>>> origin/main
```

#### Шаг 3: Отредактировать файл

Выберите один из вариантов:

**Вариант A: Оставить вашу версию**
```
Ваша локальная версия кода
```

**Вариант B: Принять версию с GitHub**
```
Версия кода из GitHub
```

**Вариант C: Объединить обе версии**
```
Ваша локальная версия кода
Версия кода из GitHub
```

Удалите маркеры `<<<<<<<`, `=======`, `>>>>>>>`.

#### Шаг 4: Отметить конфликт как решённый

```bash
# Добавить исправленный файл
git add file.txt

# Проверить статус
git status
```

#### Шаг 5: Завершить слияние

```bash
# Завершить merge
git commit -m "Resolve merge conflict in file.txt"

# Отправить на GitHub
git push origin main
```

### Отмена слияния при конфликтах

Если решение конфликта слишком сложное:

```bash
# Отменить процесс слияния
git merge --abort

# Или отменить rebase
git rebase --abort
```

### Использование инструментов для решения конфликтов

```bash
# Запустить визуальный инструмент для разрешения конфликтов
git mergetool

# Настроить VS Code как mergetool
git config --global merge.tool vscode
git config --global mergetool.vscode.cmd 'code --wait $MERGED'
```

---

## Сценарий 6: Отмена изменений

### Отмена незакоммиченных изменений

```bash
# Отменить изменения в конкретном файле
git restore file.txt
# Или старый синтаксис
git checkout -- file.txt

# Отменить все незакоммиченные изменения
git restore .
git checkout -- .

# Удалить все новые неотслеживаемые файлы
git clean -fd
```

### Отмена последнего коммита (не отправленного на GitHub)

```bash
# Отменить коммит, сохранив изменения в файлах
git reset --soft HEAD~1

# Отменить коммит и изменения в staging, но сохранить файлы
git reset --mixed HEAD~1
# или просто
git reset HEAD~1

# ОСТОРОЖНО: Полностью удалить коммит и все изменения
git reset --hard HEAD~1
```

### Отмена коммита, уже отправленного на GitHub

```bash
# Создать новый коммит, отменяющий изменения
git revert HEAD

# Отменить конкретный коммит
git revert <commit-hash>

# Отправить на GitHub
git push origin main
```

**Разница между reset и revert:**
- **reset**: Удаляет коммиты из истории (опасно для публичных веток)
- **revert**: Создаёт новый коммит, отменяющий изменения (безопасно)

### Откат к конкретному коммиту

```bash
# Посмотреть историю
git log --oneline

# Вернуться к конкретному коммиту (сохранив изменения)
git reset --soft <commit-hash>

# ОСТОРОЖНО: Жёсткий откат (потеря всех изменений)
git reset --hard <commit-hash>

# Если коммит уже на GitHub, нужен force push
git push --force origin main
```

---

## Сценарий 7: Принудительная перезапись

**ОСТОРОЖНО:** Используйте только если точно знаете, что делаете!

### Перезаписать удалённый репозиторий вашей локальной версией

```bash
# ОПАСНО: Это удалит все изменения на GitHub!
git push --force origin main

# Более безопасная версия (не перезапишет, если на GitHub новые коммиты)
git push --force-with-lease origin main
```

### Заменить локальный репозиторий версией с GitHub

```bash
# ОСТОРОЖНО: Это удалит все локальные изменения!

# 1. Получить данные с GitHub
git fetch origin

# 2. Сбросить локальную ветку
git reset --hard origin/main

# 3. Удалить неотслеживаемые файлы
git clean -fd
```

### Полная перезагрузка репозитория

```bash
# Крайняя мера: удалить и заново склонировать
cd ..
rm -rf repository-name
git clone git@github.com:username/repository-name.git
cd repository-name
```

---

## Полезные команды

### Просмотр различий

```bash
# Показать изменения в незакоммиченных файлах
git diff

# Показать изменения в staged файлах
git diff --staged

# Сравнить с удалённой веткой
git diff origin/main

# Сравнить два коммита
git diff <commit1> <commit2>

# Показать изменения в конкретном файле
git diff file.txt
```

### Работа с историей

```bash
# Красивый вывод истории
git log --oneline --graph --all --decorate

# Подробная история с изменениями
git log -p

# История конкретного файла
git log --follow file.txt

# Поиск по коммитам
git log --grep="ключевое слово"

# Кто и когда изменял файл
git blame file.txt
```

### Информация о ветках

```bash
# Список локальных веток
git branch

# Список всех веток (включая удалённые)
git branch -a

# Показать последний коммит каждой ветки
git branch -v

# Показать слитые ветки
git branch --merged

# Показать неслитые ветки
git branch --no-merged
```

### Работа с удалёнными репозиториями

```bash
# Показать удалённые репозитории
git remote -v

# Добавить новый удалённый репозиторий
git remote add upstream https://github.com/original/repo.git

# Изменить URL удалённого репозитория
git remote set-url origin git@github.com:username/repo.git

# Удалить удалённый репозиторий
git remote remove origin

# Получить изменения со всех удалённых репозиториев
git fetch --all
```

---

## Рекомендации и best practices

### Ежедневная работа

1. **Начинайте день с pull**
   ```bash
   git pull origin main
   ```

2. **Коммитьте часто, пушьте регулярно**
   ```bash
   git add .
   git commit -m "Понятное описание изменений"
   git push origin main
   ```

3. **Проверяйте статус перед коммитом**
   ```bash
   git status
   git diff
   ```

### Работа в команде

1. **Используйте ветки для новых функций**
   ```bash
   git checkout -b feature/new-feature
   # Работаете над фичей
   git push origin feature/new-feature
   # Создаёте Pull Request на GitHub
   ```

2. **Синхронизируйтесь с main регулярно**
   ```bash
   git checkout main
   git pull origin main
   git checkout feature/new-feature
   git merge main
   ```

3. **Используйте осмысленные сообщения коммитов**
   ```
   ❌ "fix"
   ❌ "update"
   ✅ "Fix user authentication bug in login form"
   ✅ "Add email validation to registration"
   ```

### Безопасность

1. **Никогда не используйте `--force` на общих ветках**
   - Используйте `--force-with-lease` как более безопасную альтернативу

2. **Создавайте резервные копии перед опасными операциями**
   ```bash
   git branch backup-branch
   ```

3. **Используйте `.gitignore`**
   ```
   # Не коммитьте секреты, пароли, ключи API
   .env
   config/secrets.yml
   *.key
   ```

### Решение проблем

1. **Если сомневаетесь — создайте ветку**
   ```bash
   git checkout -b experiment
   # Пробуете решение
   # Если не получилось:
   git checkout main
   git branch -D experiment
   ```

2. **Используйте `git reflog` для восстановления**
   ```bash
   # Показать все действия в репозитории
   git reflog
   
   # Вернуться к предыдущему состоянию
   git reset --hard HEAD@{2}
   ```

3. **Не паникуйте!**
   - Git редко удаляет данные навсегда
   - Почти всё можно восстановить с помощью `reflog`
   - В крайнем случае можно склонировать репозиторий заново

---

## Шпаргалка: Быстрые решения

| Ситуация | Команда |
|----------|---------|
| Получить изменения с GitHub | `git pull origin main` |
| Отправить изменения на GitHub | `git push origin main` |
| Отложить изменения | `git stash` |
| Вернуть отложенные изменения | `git stash pop` |
| Отменить незакоммиченные изменения | `git restore .` |
| Отменить последний коммит | `git reset --soft HEAD~1` |
| Решить конфликт слияния | Отредактировать → `git add` → `git commit` |
| Отменить слияние | `git merge --abort` |
| Посмотреть различия | `git diff` |
| Посмотреть историю | `git log --oneline --graph` |

---

## Дополнительные ресурсы

- [Официальная документация Git](https://git-scm.com/doc)
- [GitHub Docs](https://docs.github.com/)
- [Git Cheat Sheet](https://education.github.com/git-cheat-sheet-education.pdf)
- [Визуализация команд Git](https://git-school.github.io/visualizing-git/)

---

**Помните:** Практика — лучший учитель. Чем больше вы работаете с Git, тем увереннее становитесь в решении конфликтов и синхронизации репозиториев!
